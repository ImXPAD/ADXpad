.TH "xpad" 3 "Fri Jul 17 2015" "Version 4" "XPad detectors driver for AreaDetector (EPICS)" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xpad \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBxpad\fP (const char *portName, const char *xpadPort, int maxBuffers, size_t maxMemory, int priority, int stackSize)"
.br
.RI "\fICreate and initialize the driver and it's parameters\&. \fP"
.ti -1c
.RI "virtual asynStatus \fBwriteInt32\fP (asynUser *pasynUser, epicsInt32 value)"
.br
.RI "\fIDoes not only write, called when a parameter is written, this performs associated actions\&. \fP"
.ti -1c
.RI "virtual void \fBreport\fP (FILE *fp, int details)"
.br
.RI "\fIReport status of the driver\&. \fP"
.ti -1c
.RI "asynStatus \fBxpadInit\fP ()"
.br
.RI "\fIInitialize the detector and asks if it is ready to be the best detector ever\&. \fP"
.ti -1c
.RI "void \fBxpadTask\fP ()"
.br
.RI "\fIMain xpad Thread\&. \fP"
.ti -1c
.RI "asynStatus \fBgetImageStream\fP ()"
.br
.RI "\fIStart the exposure with the previously given parameters catch the image sent by the server\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "epicsEventId \fBstartEventId\fP"
.br
.ti -1c
.RI "epicsEventId \fBstopEventId\fP"
.br
.ti -1c
.RI "epicsEventId \fBabortEventId\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "int \fBxpad_acq_mode\fP"
.br
.ti -1c
.RI "int \fBxpad_geo_correction\fP"
.br
.RI "\fIToggle geometrical correction: default 0\&. \fP"
.ti -1c
.RI "int \fBxpad_flat_field\fP"
.br
.RI "\fIToggle flat field correction: default 0\&. \fP"
.ti -1c
.RI "int \fBxpad_img_transfer\fP"
.br
.RI "\fIimage transfer flag \fP"
.ti -1c
.RI "int \fBxpadChangeMode\fP"
.br
.ti -1c
.RI "int \fBxpad_input\fP"
.br
.RI "\fIoften called triggers \fP"
.ti -1c
.RI "int \fBxpad_output\fP"
.br
.ti -1c
.RI "int \fBxpad_overflow\fP"
.br
.ti -1c
.RI "int \fBxpad_outformat\fP"
.br
.ti -1c
.RI "int \fBxpad_stacksize\fP"
.br
.ti -1c
.RI "int \fBxpad_outpath\fP"
.br
.ti -1c
.RI "int \fBxpadAbort\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "asynStatus \fBreadFile\fP (const char *fileName, NDArray *pImage)"
.br
.ti -1c
.RI "asynStatus \fBwriteServer\fP (const char *output)"
.br
.ti -1c
.RI "asynStatus \fBreadServer\fP (char *input, size_t maxChars, double timeout)"
.br
.ti -1c
.RI "asynStatus \fBreadimgServer\fP (char *img, double timeout)"
.br
.ti -1c
.RI "asynStatus \fBsetExposureParameters\fP (void)"
.br
.RI "\fIControl and possible resetting of every exposure parameter\&. \fP"
.ti -1c
.RI "asynStatus \fBchangeMode\fP ()"
.br
.ti -1c
.RI "void \fBreadoutFrame\fP (int bufferNumber, const char *fileName, int wait)"
.br
.ti -1c
.RI "void \fBgetImageDataTask\fP ()"
.br
.ti -1c
.RI "asynStatus \fBwaitForCompletion\fP (const char *doneString, char *returnstr, double timeout)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "char \fBemptystr\fP [128]"
.br
.ti -1c
.RI "epicsTimeStamp \fBacqStartTime\fP"
.br
.ti -1c
.RI "epicsTimeStamp \fBacqEndTime\fP"
.br
.ti -1c
.RI "epicsTimerId \fBtimerId\fP"
.br
.ti -1c
.RI "\fBxpad_mode\fP \fBmode\fP"
.br
.ti -1c
.RI "char \fBtoServer\fP [256]"
.br
.ti -1c
.RI "char \fBfromServer\fP [15000]"
.br
.ti -1c
.RI "asynUser * \fBpasynUserServer\fP"
.br
.ti -1c
.RI "bool \fBready\fP"
.br
.ti -1c
.RI "const char * \fBserverPort\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Driver for xpad online pixel array detectors; communicates with the XpadPCIServer and XPadUSBServer programs over a TCP/IP socket \&. The XPadXXXServer program must be running listening for commands on a given port\&. This is done by running it on a specified port f\&.e\&. 'XpadPCIServer 3456' In this example 3456 is the TCP/IP port number that the XpadXXXServer and this driver will use to communicate\&. If you are running the server on another port please change the value in the st\&.cmd file 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBxpad::xpad\fP (const char *portName, const char *serverPort, intmaxBuffers, size_tmaxMemory, intpriority, intstackSize)"
.PP
Create and initialize the driver and it's parameters\&. Constructor for xpad driver; most parameters are simply passed to ADDriver::ADDriver\&. After calling the base class constructor this method creates a thread to collect the detector data, and sets reasonable default values for the parameters defined in this class and ADDriver\&. 
.PP
\fBParameters:\fP
.RS 4
\fIportName\fP The name of the asyn port driver to be created\&. 
.br
\fIserverPort\fP The name of the asyn port driver previously created with drvAsynIPPortConfigure connected to the xpaddtb program\&. 
.br
\fImaxBuffers\fP The maximum number of NDArray buffers that the NDArrayPool for this driver is
.RE
.PP
allowed to allocate\&. Set this to -1 to allow an unlimited number of buffers\&. 
.PP
\fBParameters:\fP
.RS 4
\fImaxMemory\fP The maximum amount of memory that the NDArrayPool for this driver is allowed to allocate\&. Set this to -1 to allow an unlimited amount of memory\&. 
.br
\fIpriority\fP The thread priority for the asyn port driver thread\&. 
.br
\fIstackSize\fP The stack size for the asyn port driver thread\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "asynStatus \fBxpad::changeMode\fP ()\fC [private]\fP"
.SS "void \fBxpad::getImageDataTask\fP ()\fC [private]\fP"
.SS "asynStatus \fBxpad::getImageStream\fP ()"
.PP
Start the exposure with the previously given parameters catch the image sent by the server\&. Set of first parameters
.PP
Start the exposure and wait for the server resposne
.PP
We use the first recieved bytes to set and allocate the logical structure that will serve as a buffer for our image
.PP
Ghetto conversion from recieved octets to 32bits integers
.PP
the image is streamed that way: (datasize)(width)(height)(data) :: (uint32)(uint32)(uint32)((uint32)*width*height)
.PP
Transfer of the recieved frames in the buffer
.PP
Last parameters (could be compared to metadatas) are then set
.PP
Once complete the buffer is transfered where it is needed
.PP
Memory release 
.SS "asynStatus \fBxpad::readFile\fP (const char *fileName, NDArray *pImage)\fC [private]\fP"
.SS "asynStatus \fBxpad::readimgServer\fP (char *img, doubletimeout)\fC [private]\fP"
.SS "void \fBxpad::readoutFrame\fP (intbufferNumber, const char *fileName, intwait)\fC [private]\fP"
.SS "asynStatus \fBxpad::readServer\fP (char *input, size_tmaxChars, doubletimeout)\fC [private]\fP"
.SS "void \fBxpad::report\fP (FILE *fp, intdetails)\fC [virtual]\fP"
.PP
Report status of the driver\&. Report status of the driver\&. Prints details about the driver if details>0\&. It then calls the ADDriver::report() method\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfp\fP File pointed passed by caller where the output is written to\&. 
.br
\fIdetails\fP If >0 then driver details are printed\&. 
.RE
.PP

.SS "asynStatus \fBxpad::setExposureParameters\fP (void)\fC [private]\fP"
.PP
Control and possible resetting of every exposure parameter\&. This control parameters set by the user and send it to the XPad if it is the first exposure or for a reason ther was a bug on the last one We initialize the XPAD detector
.PP
The core of this function mainly control the values of every exposure parameters and reset them in case of bad values Parameters such as:
.PP
Acquisiton mode
.PP
Geometrical correction flag
.PP
Flat field correction flag
.PP
Image transfer flag
.PP
Input signals (trigger modes)
.PP
Output signal
.PP
Number of Images
.PP
Exposure Time
.PP
Time between images
.PP
Overflow Time
.PP
Output format
.PP
Image number/stack
.PP
Output server filepath
.PP
Sendin config to server
.PP
We need the image size to prepare the buffer recieving the image This can change depending on geometrical corection status this cannot work on XpadServer under version 3\&.0 so for now its on commented in the source till servers are updated 
.SS "asynStatus \fBxpad::waitForCompletion\fP (const char *doneString, char *returnstr, doubletimeout)\fC [private]\fP"
.SS "asynStatus \fBxpad::writeInt32\fP (asynUser *pasynUser, epicsInt32value)\fC [virtual]\fP"
.PP
Does not only write, called when a parameter is written, this performs associated actions\&. Called when asyn clients call pasynInt32->write()\&. This function performs actions for some parameters, including ADAcquire, xpadErase, etc\&. For all parameters it sets the value in the parameter library and calls any registered callbacks\&.\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpasynUser\fP pasynUser structure that encodes the reason and address\&. 
.br
\fIvalue\fP Value to write\&. 
.RE
.PP

.SS "asynStatus \fBxpad::writeServer\fP (const char *output)\fC [private]\fP"
.SS "asynStatus \fBxpad::xpadInit\fP ()"
.PP
Initialize the detector and asks if it is ready to be the best detector ever\&. 
.SS "void \fBxpad::xpadTask\fP ()"
.PP
Main xpad Thread\&. This thread controls handling of slow events - erase, acquire, change mode 
.SH "Member Data Documentation"
.PP 
.SS "epicsEventId \fBxpad::abortEventId\fP"
.SS "epicsTimeStamp \fBxpad::acqEndTime\fP\fC [private]\fP"
.SS "epicsTimeStamp \fBxpad::acqStartTime\fP\fC [private]\fP"
.SS "char \fBxpad::emptystr\fP[128]\fC [private]\fP"
.SS "char \fBxpad::fromServer\fP[15000]\fC [private]\fP"
.SS "\fBxpad_mode\fP \fBxpad::mode\fP\fC [private]\fP"
.SS "asynUser* \fBxpad::pasynUserServer\fP\fC [private]\fP"
.SS "bool \fBxpad::ready\fP\fC [private]\fP"
.SS "const char* \fBxpad::serverPort\fP\fC [private]\fP"
.SS "epicsEventId \fBxpad::startEventId\fP"Should be private but accessed from C, must be public 
.SS "epicsEventId \fBxpad::stopEventId\fP"
.SS "epicsTimerId \fBxpad::timerId\fP\fC [private]\fP"
.SS "char \fBxpad::toServer\fP[256]\fC [private]\fP"
.SS "int \fBxpad::xpad_acq_mode\fP\fC [protected]\fP"
.SS "int \fBxpad::xpad_flat_field\fP\fC [protected]\fP"
.PP
Toggle flat field correction: default 0\&. 
.SS "int \fBxpad::xpad_geo_correction\fP\fC [protected]\fP"
.PP
Toggle geometrical correction: default 0\&. 
.SS "int \fBxpad::xpad_img_transfer\fP\fC [protected]\fP"
.PP
image transfer flag At the end of exposure if set to true the images will be send in binary via tcp if set to 0 they will be saved in 'output server filepath' 
.SS "int \fBxpad::xpad_input\fP\fC [protected]\fP"
.PP
often called triggers 
.SS "int \fBxpad::xpad_outformat\fP\fC [protected]\fP"
.SS "int \fBxpad::xpad_outpath\fP\fC [protected]\fP"
.SS "int \fBxpad::xpad_output\fP\fC [protected]\fP"
.SS "int \fBxpad::xpad_overflow\fP\fC [protected]\fP"
.SS "int \fBxpad::xpad_stacksize\fP\fC [protected]\fP"
.SS "int \fBxpad::xpadAbort\fP\fC [protected]\fP"
.SS "int \fBxpad::xpadChangeMode\fP\fC [protected]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for XPad detectors driver for AreaDetector (EPICS) from the source code\&.
